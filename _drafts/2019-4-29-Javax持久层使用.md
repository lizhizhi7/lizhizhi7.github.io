
### Examples

```Java
@SuppressWarnings("serial")
@Entity
@Table(name="T_X")
public class X implements Serializable
{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Column(length=32)
    private String name;

    @Transient   //表示此数据不在数据库表里建立属性
    private String temp;

    @Temporal(TemporalType.TIMESTAMP) //这个是带时分秒的类型
    private Date date;

    @OneToOne(cascade = CascadeType.ALL, mappedBy = "x")
    private A a;
}

@SuppressWarnings("serial")
@Entity
@Table(name="T_A")
public class A implements Serializable
{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "a", fetch = FetchType.EAGER)
    private List<B> b = new ArrayList<B>();

    @OneToOne()
    @JoinColumn(name = "x_Id") //加这句后就会双方共同维护关系
    private X x;
}

@SuppressWarnings("serial")
@Entity
public class B implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected int id;

    @ManyToOne()
    @JoinColumn(name = "a_id")
    protected A a;
}
```

要注意的是：fetch = FetchType.EAGER这句话在一个类里面只能出现一次，出现两次就会报错“cannot simultaneously fetch multiple bags”，要把其他的改为fetch = FetchType.LAZY延迟加载就可以了。听说把List集合改为Set也能解决这个错误。 


其他要点： 
1、@Table(name="T_X")这句话可以不写，不写就已类名作为表名 

2、如果想让两个类的属性生成一个数据表，在一个类里这样加入另一个类即可： @Embedded 
private C c; 


3、如果想要一个类继承另一个类的所有属性，则在父类里这样写： 
@SuppressWarnings("serial") 
@Entity 
@MappedSuperclass   //增加这一行 
并把父类的所有属性的private改为protected即可 


4、建议在一对多关联中在"一"方用延迟加载"多"方可以在HQL中显式的"迫切左外连接" left join fetch 这样做Hibernate可以少访问数据库,也可以用"@BatchSize(size = 5)"来减少访问数据库的次数 

@Id 声明属性为主键 

@GeneratedValue表示主键是自动生成策略，一般该注释和 @Id 一起使用 

@Entity 任何 hibernte 映射对象都要有次注释 

@Table(name = “tablename”) 类声明此对象映射到哪个表 

@Column(name = “Name”,nullable=false,length=32) 声明数据 库字段和类属性对应关系 

@Lob 声明字段为 Clob 或 Blob 类型

@OneToMany(mappedBy=”order”,cascade = CascadeType.ALL, fetch = FetchType.LAZY) 
   @OrderBy(value = “id ASC”) 
   一对多声明，和 ORM 产品声明类似，一看就明白了。 
   @ManyToOne(cascade=CascadeType.REFRESH,optional=false) 
   @JoinColumn(name = “order_id”) 
   声明为双向关联 



@Temporal(value=TemporalType.DATE) 做日期类型转换。 

@OneToOne(optional= true,cascade = CascadeType.ALL, mappedBy = “person”) 
   一对一关联声明 
   @OneToOne(optional = false, cascade = CascadeType.REFRESH) 
   @JoinColumn(name = “Person_ID”, referencedColumnName = “personid”,unique = true) 
   声明为双向关联 



 @ManyToMany(mappedBy= “students”) 
   多对多关联声明。 
  @ManyToMany(cascade = CascadeType.PERSIST, fetch = FetchType.LAZY) 
  @JoinTable(name = “Teacher_Student”, 
    joinColumns = {@JoinColumn(name = “Teacher_ID”, referencedColumnName = “teacherid”)}, 
    inverseJoinColumns = {@JoinColumn(name = “Student_ID”, referencedColumnName = 
    “studentid”)}) 
   多对多关联一般都有个关联表，是这样声明的！ 



 @Transiten表示此属性与表没有映射关系，是一个暂时的属性 

@Cache(usage= CacheConcurrencyStrategy.READ_WRITE)表示此对象应用缓存 


JPA 与 hibernate关系


1,JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。

2,Hibernate作为JPA的一种实现,jpa的注解已经是hibernate的核心，hibernate只提供了一些补充，而不是两套注解。hibernate对jpa的支持够足量，在使用hibernate注解建议使用jpa。