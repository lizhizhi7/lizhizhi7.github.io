---
layout:     post
title:      汇编基础知识
subtitle:   Assemble
date:       2019-5-30
author:     Lee
header-img: img/background-nasm.jpg
catalog: true
tags:
    - 汇编
    - nasm
---

## 字节与字

在汇编的数据存储中,有两个比较常用的单位:字节和字。(相当于高级语言中的 int,long,float 等数据类型)。  
我们在汇编中只能定义两种数据类型的数据,字节类型(byte类型),字类型(word类型)  

* 字节:byte,1个byte由8个bit组成,可以存储在8位寄存器中。
* 字:word,1个字由两个字节组成，可以存储在一个16位寄存器中,这个字的高字节\低字节分别存储在这个存储器的高8位和低8位寄存器中，称为字的高字节和低字节。

> 比如数据4E20H (01001110 00100000B),高字节值78,低字节值32。

## 寄存器

### 通用寄存器

`AX BX CX DX` 这4个寄存器通常用来存放一般性的数据(eg: int a = 10 , int b = 10 ) 称为通用寄存器(有时也有特殊用途)。

* AX――累加器（Accumulator），使用频度最高
* BX――基址寄存器（Base Register），常存放存储器地址
* CX――计数器（Count Register），常作为计数器
* DX――数据寄存器（Data Register），存放数据

通常,CPU会先将内存中的数据存储到通用寄存器中,然后在对通用寄存器中的数据进行运算。  

假如,内存中有块红色内存空间的值是3,现在想把他加1,并将结果存储到内存中的蓝色内存空间,那么处理流程大致如下:  

* CPU 首先会将红色内存空间中的值放到 `AX` 寄存器中(通用寄存器)中,即: `mov ax, 红色内存空间` (将右边边红色内存空间的值存到左边 `AX` 中 )  
* 然后让AX 寄存器(通用寄存器)与1相加.即: add ax ,1 (将右边的值1,与左边 `AX` 中的值相加并将结果存入左边 `AX` 中)  
* 最后将值(结果)赋值给蓝色内存空间.即: `mov 蓝色内存空间, AX` (将右侧 `AX` 中的值移动到左侧蓝色内存中)  

`AX BX CX DX` 这4个通用寄存器都是16位的,可以存储2个字节，而上一代8086的寄存器都是8位的,为了保证兼容, `AX BX CX DX` 都可以分为2个8位的寄存器来使用。

### 段寄存器和指针寄存器

一般来说，CPU在访问内存的时候要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。8086CPU有4个段寄存器：

* 代码段寄存器: CS (code segment) 存放代码
* 数据段寄存器: DS (data segment) 存放数据
* 堆栈段寄存器: SS (stack segment) 对象放堆里面,局部对象放栈里面
* 附加段寄存器: ES (Extra segment)

#### CS:IP

典型的提供代码段地址和偏移地址的寄存器为CS和IP寄存器。CPU执行指令的步骤一般是：

（1）将CS、IP中的内容送入地址加法器（段地址*16+偏移地址）合成物理地址。
（2）地址加法器将物理地址送入输入输出控制电路
（3）输入输出控制电路将物理地址送上地址总线
（4）然后CPU从物理地址指向的内存单元读取机器指令，并将机器指令通过数据总线送入CPU的输入输出控制电路。
（5）输入输出控制电路将读取的指令送入指令缓冲器，同时IP的内容更新为原内容加指令长度。
（6）然后，执行控制器执行机器指令，并将执行后的内容送入相应的寄存器。

##### 修改

修改CS、IP的指令不同于修改通用的寄存器值的指令。修改通用寄存器的值可以用mov 指令（mav ax,123），mov指令被称为传送指令。修改CS、IP的指令是jmp指令。jmp指令被称为转移指令。

* 同时修改代码段寄存器和指令指针寄存器，形如`jmp 段地址：偏移地址`

`jmp 2AE3:3`,执行后：CS=2AE3H，IP=0003H,CPU将在2AE33H处读取指令

* 仅想修改IP的内容，形如 `jmp 某一合法寄存器` ,功能是用某一合法寄存器中的值修改IP的内容

`jmpax`  指令执行前：ax=1000H,CS=2000H,IP=0003H
         指令执行后：ax=1000H,CS=2000H,IP=1000H

##### 使用

在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64KB,因为偏移地址长度为16位，最大为64KB）的一组代码存在一组连续、起始地址为16的倍数的内存单元中。这样，这段内存就可以看成是代码段，用来存放代码的。

#### DS:SI&ES:DI

DS:SI和ES:DI配对时通常用来执行一些字符串操作。  
SI和DI两个寄存器叫做索引寄存器, 这两个寄存器通常用来处理数组或字符串。  
SI叫做源索引寄存器, DI叫做目的索引寄存器. 正如它们的命名, SI通常指向源数组, DI通常指向目的数组。  
他们通常被用来成块地移动数据, 比如移动数组或结构体. SI和DI通常和DS和ES一起使用。  

#### BP&SP&&IP

BP是基指针, SP是栈指针, IP是指令指针。  
通常BP用来保存使用局部变量的地址。  
SP用来指向当前的栈。
> 尽管SP可以被很容易地修改, 你还是一定要非常小心. 因为如果这个寄存器搞错了, 你的程序就毁了。

IP用来指示当前运行程序的当前指针，通常和CS一起使用，IP是不允许修改的。所以，你不能直接访问CS, 也不能直接访问IP。

## 常用指令

### lodsb

#### LODSB/LODSW

取字符串指令LODSB／LODSW将位于DS段由SI所指的存储单元的内容取到AL或AX中。用LODSB时，取的是字节，取完后，地址自动加1或减l；用LODSW时取的是字，取完后地址自动加2或减2。当方向标志位DF=0时，则esi自动增加；DF=1时，esi自动减小。

因为使用LODSB／lODSW指令时，取来的字节或字放在AL或AX中，所以LODSB／LODSW指令前不能加前缀，否则，AL或AX中的内容会被后一次取到的内容所覆盖，最后只能得到字符串的最后1个字节或字。实际使用时，LODSB／LODSW指令一般用在循环程序中。

### CLI STI CLD STD

#### CLI/STI (Clear Interupt / Set Interupt)

CLI和STI是用来屏蔽中断和恢复中断用的，如 设置栈基址SS和偏移地址SP时，需要CLI，因为如果这两条指令被分开了，那么很有可能SS被修改了，但由于中断，而代码跳去其它地方执行了，SP还没来得及修改，就有可能出错。

#### CLD/STD (Clear Director / Set Director)

CLD和STD是在字行块传送时使用的，它们决定了块传送的方向，CLD是使得传送方向从低地址到高地址，而STD就刚好相反了。
