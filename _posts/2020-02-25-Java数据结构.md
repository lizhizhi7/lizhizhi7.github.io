---
layout:     post
title:      Java数据结构
subtitle:   Java Data Structure
date:       2020-2-25
author:     Oliver Li
header-img: img/background-java.jpg
catalog:    true
tags:
    - Java
    - 数据结构
---

Java中的各种容器眼花缭乱，但是大部分其实都是对基础数据结构的封装。比如HashMap依赖于Node数组，LinkedList底层是链表，ArrayList是对数组的再封装。

总的来说，Java最基础的数据结构，大概就是以下三种

* 数组
* 链表
* Hash(Hash的操作与数组以及链表不太一致)

## 数组

### ArrayList

ArrayList是我们开发中非常常用的数据存储容器之一，其底层是数组实现的，我们可以在集合中存储任意类型的数据，ArrayList是**线程不安全**的，非常适合用于**对元素进行查找**，效率非常高。

对ArrayList的操作一般分为**两个步骤**，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。

#### 内部属性

```java
/**
 * 默认初始化容量
 */
private static final int DEFAULT_CAPACITY = 10;

/**
 * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。
 */
private static final Object[] EMPTY_ELEMENTDATA = {};

/**
 * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。
 */
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
 * 这就是ArrayList底层用到的数组

 * 非私有，以简化嵌套类访问
 * transient 在已经实现序列化的类中，不允许某变量序列化
 */
transient Object[] elementData;

/**
 * 实际ArrayList集合大小
 */
private int size;

/**
 * 可分配的最大容量
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
```

##### 什么是序列化?

序列化是指：将对象转换成以字节序列的形式来表示，以便用于持久化和传输。

实现方法：实现`Serializable`接口。

然后用的时候拿出来进行反序列化即可又变成Java对象。

##### transient关键字

Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。

有了transient关键字声明，则这个变量不会参与序列化操作，即使所在类实现了Serializable接口，反序列化后该变量为空值。

那么问题来了：ArrayList中数组声明：`transient Object[] elementData;`，事实上我们使用ArrayList在网络传输用的很正常，并没有出现空值。

原来：ArrayList在序列化的时候会调用`writeObject()`方法，将size和element写入ObjectOutputStream；反序列化时调用`readObject()`，从ObjectInputStream获取size和element，再恢复到elementData。

那为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？

原因在于**elementData是一个缓存数组**，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上述的方式来实现序列化时，就可以**保证只序列化实际存储的那些元素**，而不是整个数组，从而节省空间和时间。

#### 构造方法

根据`initialCapacity`初始化一个空数组，如果值为0，则初始化一个空数组:

```java
/**
 * 根据initialCapacity 初始化一个空数组
 */
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}
```

不带参数初始化，默认容量为10:

```java
/**
 * 不带参数初始化，默认容量为10
 */
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

通过集合做参数的形式初始化：如果集合为空，则初始化为空数组：

```java
/**
 * 通过集合做参数的形式初始化
 */
public ArrayList(Collection<? extends E> c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```

#### 主干方法

##### trimToSize()

```java
/**
 * 这个方法用来最小化实例存储,将容器大小调整为当前元素所占用的容量大小。
 */
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = (size == 0)
          ? EMPTY_ELEMENTDATA
          : Arrays.copyOf(elementData, size);
    }
}
```

##### clone()

```java
/**
 * 用来克隆出一个新数组。
 */
public Object clone() {
    try {
        ArrayList<?> v = (ArrayList<?>) super.clone();
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new InternalError(e);
    }
}
```

通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。

##### add(E e)

```java
/**
 * 在数组末尾添加元素
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
```

这个方法里又嵌套调用了两个方法:计算容量+确保容量

计算容量：如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1

```java
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
```

计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数)

如果size+1 > elementData.length证明数组已经放满，则增加容量，调用grow()。

```java
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```

## 链表

### LinkedList

## Hash
