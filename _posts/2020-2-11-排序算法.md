---
layout:     post
title:      排序算法
subtitle:   Sort Algorithm
date:       2020-2-11
author:     Oliver Li
header-img: img/background-java.jpg
catalog:    true
tags:
    - Algorithm
---

|排序算法|平均时间复杂度|
|:-:|:-:|
|冒泡排序|$O(n^2)$|
|选择排序|$O(n^2)$|
|插入排序|$O(n^2)$|
|希尔排序|$O(n^{1.5})$|
|快速排序|$O(N*logN)$|
|归并排序|$O(N*logN)$|
|堆排序|$O(N*logN)$|
|基数排序|$O(d(n+r))$|

## 冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。  
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。  
冒泡排序是稳定排序算法，时间复杂度$O(n^2)$。

## 选择排序

选择排序算法的基本思路是为每一个位置选择当前最小的元素。

选择排序的基本思想是，基于直接选择排序和堆排序这两种基本的简单排序方法。首先从第1个位置开始对全部元素进行选择，选出全部元素中最小的给该位置，再对第2个位置进行选择，在剩余元素中选择最小的给该位置即可；以此类推，重复进行“最小元素”的选择，直至完成第(n-1)个位置的元素选择，则第n个位置就只剩唯一的最大元素，此时不需再进行选择。使用这种排序时，要注意其中一个不同于冒泡法的细节。

> 举例说明：序列58539．我们知道第一遍选择第1个元素“5”会和元素“3”交换，那么原序列中的两个相同元素“5”之间的前后相对顺序就发生了改变。因此，我们说选择排序不是稳定的排序算法，它在计算过程中会破坏稳定性。

## 插入排序

插入排序（Insertion sort）是一种简单直观且稳定的排序算法。

如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法，算法适用于少量数据的排序，时间复杂度$O(n^2)$。是稳定的排序方法。  

插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，这种比较是从该有序序列的最末端开始执行，即要插入序列中的元素最先和有序序列中最大的元素比较，若其大于该最大元素，则可直接插入最大元素的后面即可，否则再向前一位比较查找直至找到应该插入的位置为止。执行过程中，若遇到和插入元素相等的位置，则将要插人的元素放在该相等元素的后面，因此插入该元素后并未改变原序列的前后顺序。

* 直接插入排序
* 二分插入排序（折半插入排序）
* 希尔排序

## 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。
基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。  
排序流程如下：

1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。
2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

性能分析：

快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是$O(n)$；而整个快速排序算法的时间复杂度与划分的趟数有关。  

理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过$log_2n$趟划分，便可得到长度为1的子表。这样，整个算法的时间复杂度为$O(nlog_2n)$。  

最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为$O(n^2)$。  

为改善最坏情况下的时间性能，可采用其他方法选取中间数。通常采用“三者值取中”方法，即比较`H->r[low].key`、`H->r[high].key`与`H->r[(10w+high)/2].key`，取三者中关键字为中值的元素为中间数。  

可以证明，快速排序的平均时间复杂度也是$O(nlog_2n)$。因此，该排序方法被认为是目前最好的一种内部排序方法。

从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为$log_2(n+1)$；但最坏的情况下，栈的最大深度为$n$。这样，快速排序的空间复杂度为$O(log_2n)$。

## 归并排序

归并排序算法就是把序列递归划分成为一个个短序列，以其中只有1个元素的直接序列或者只有2个元素的序列作为短序列的递归出口，再将全部有序的短序列按照一定的规则进行排序为长序列。归并排序融合了分治策略，即将含有n个记录的初始序列中的每个记录均视为长度为1的子序列，再将这n个子序列两两合并得到n/2个长度为2(当凡为奇数时会出现长度为l的情况)的有序子序列；将上述步骤重复操作，直至得到1个长度为n的有序长序列。需要注意的是，在进行元素比较和交换时，若两个元素大小相等则不必刻意交换位置，因此该算法不会破坏序列的稳定性，即归并排序也是稳定的排序算法。
