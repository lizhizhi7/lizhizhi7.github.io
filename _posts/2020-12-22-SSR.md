---
layout:     post
title:      SSR
subtitle:   Server Side Rendering
date:       2020-12-22
author:     Oliver Li
catalog:    true
tags:
    - SSR
    - React
---

# SSR

如何在现有的这套模块化、成熟的渲染架构之上使用SSR呢，一开始我们往常规的思路去想，直接在文档 HTML 响应中返回服务端渲染完成的 HTML，看下来存在几个问题：

- 改造成本高，对现有的服务端架构改动比较大（CDN 缓存失效，文档服务的要求更高）
- 无法复用现有的客户端性能优化能力，比如客户端主文档/Assets 缓存和数据预加载能力，会劣化完全可交互时间
- CDN 缓存无法利用，TTFB 的时间增加，带来了新的 “完全白屏阶段”
- SSR 服务不稳定因素较多，自动降级为CSR的方案复杂，无法保证 100% 能够降级
- 主文档 HTML 的安全防护能力较弱，难以抵御黑产的恶意抓取

**核心问题**

大方向确定了，我们再来看看 SSR 应用到生产中还存在哪些核心问题

1. 如何做到 CSR/SSR 的平滑切换
2. 开发者如何开发出“能 SSR”的代码
3. 开发者面向前端编写的代码在服务端运行的不可控风险
4. 低代码搭建场景下，在服务端解决楼层模块代码加载的问题
5. 服务端性能
6. 怎么衡量优化的价值

尽管我们在开发阶段通过静态代码检查等方法极力规避问题，实际上仍然存在一些针刺痛着我们的心

1. 开发者把全局变量当缓存用造成内存泄露
2. 错误的条件结束语句导致死循环
3. 未知情况页面上存在不支持 SSR 的模块

究其原因，笔者认为有以下几个急需攻克的难题:

1. UI层(前端界面)复用性极差: 前端UI代码大量采用VM(view + model)的方案，面向多样化的设计稿进行开发，代码差异化无法收敛。
2. Data层(数据处理)复用性极差: 服务端通信给前端的数据虽然已经是视图对象(view object)，但是仍旧带有鲜明的领域(Domain)属性，数据结构的差异化直接导致数据处理逻辑的复用性无法收敛。
